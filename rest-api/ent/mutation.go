// Code generated by entc, DO NOT EDIT.

package ent

import (
	"context"
	"fmt"
	"sync"
	"time"

	"github.com/depromeet/everybody-backend/rest-api/ent/album"
	"github.com/depromeet/everybody-backend/rest-api/ent/device"
	"github.com/depromeet/everybody-backend/rest-api/ent/notificationconfig"
	"github.com/depromeet/everybody-backend/rest-api/ent/picture"
	"github.com/depromeet/everybody-backend/rest-api/ent/predicate"
	"github.com/depromeet/everybody-backend/rest-api/ent/user"

	"entgo.io/ent"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeAlbum              = "Album"
	TypeDevice             = "Device"
	TypeNotificationConfig = "NotificationConfig"
	TypePicture            = "Picture"
	TypeUser               = "User"
)

// AlbumMutation represents an operation that mutates the Album nodes in the graph.
type AlbumMutation struct {
	config
	op             Op
	typ            string
	id             *int
	name           *string
	created_at     *time.Time
	clearedFields  map[string]struct{}
	user           *int
	cleareduser    bool
	picture        map[int]struct{}
	removedpicture map[int]struct{}
	clearedpicture bool
	done           bool
	oldValue       func(context.Context) (*Album, error)
	predicates     []predicate.Album
}

var _ ent.Mutation = (*AlbumMutation)(nil)

// albumOption allows management of the mutation configuration using functional options.
type albumOption func(*AlbumMutation)

// newAlbumMutation creates new mutation for the Album entity.
func newAlbumMutation(c config, op Op, opts ...albumOption) *AlbumMutation {
	m := &AlbumMutation{
		config:        c,
		op:            op,
		typ:           TypeAlbum,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAlbumID sets the ID field of the mutation.
func withAlbumID(id int) albumOption {
	return func(m *AlbumMutation) {
		var (
			err   error
			once  sync.Once
			value *Album
		)
		m.oldValue = func(ctx context.Context) (*Album, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Album.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAlbum sets the old Album of the mutation.
func withAlbum(node *Album) albumOption {
	return func(m *AlbumMutation) {
		m.oldValue = func(context.Context) (*Album, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AlbumMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AlbumMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AlbumMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetName sets the "name" field.
func (m *AlbumMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *AlbumMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Album entity.
// If the Album object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlbumMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *AlbumMutation) ResetName() {
	m.name = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *AlbumMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AlbumMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Album entity.
// If the Album object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlbumMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AlbumMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUserID sets the "user" edge to the User entity by id.
func (m *AlbumMutation) SetUserID(id int) {
	m.user = &id
}

// ClearUser clears the "user" edge to the User entity.
func (m *AlbumMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *AlbumMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *AlbumMutation) UserID() (id int, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *AlbumMutation) UserIDs() (ids []int) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *AlbumMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// AddPictureIDs adds the "picture" edge to the Picture entity by ids.
func (m *AlbumMutation) AddPictureIDs(ids ...int) {
	if m.picture == nil {
		m.picture = make(map[int]struct{})
	}
	for i := range ids {
		m.picture[ids[i]] = struct{}{}
	}
}

// ClearPicture clears the "picture" edge to the Picture entity.
func (m *AlbumMutation) ClearPicture() {
	m.clearedpicture = true
}

// PictureCleared reports if the "picture" edge to the Picture entity was cleared.
func (m *AlbumMutation) PictureCleared() bool {
	return m.clearedpicture
}

// RemovePictureIDs removes the "picture" edge to the Picture entity by IDs.
func (m *AlbumMutation) RemovePictureIDs(ids ...int) {
	if m.removedpicture == nil {
		m.removedpicture = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.picture, ids[i])
		m.removedpicture[ids[i]] = struct{}{}
	}
}

// RemovedPicture returns the removed IDs of the "picture" edge to the Picture entity.
func (m *AlbumMutation) RemovedPictureIDs() (ids []int) {
	for id := range m.removedpicture {
		ids = append(ids, id)
	}
	return
}

// PictureIDs returns the "picture" edge IDs in the mutation.
func (m *AlbumMutation) PictureIDs() (ids []int) {
	for id := range m.picture {
		ids = append(ids, id)
	}
	return
}

// ResetPicture resets all changes to the "picture" edge.
func (m *AlbumMutation) ResetPicture() {
	m.picture = nil
	m.clearedpicture = false
	m.removedpicture = nil
}

// Where appends a list predicates to the AlbumMutation builder.
func (m *AlbumMutation) Where(ps ...predicate.Album) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *AlbumMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Album).
func (m *AlbumMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AlbumMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.name != nil {
		fields = append(fields, album.FieldName)
	}
	if m.created_at != nil {
		fields = append(fields, album.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AlbumMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case album.FieldName:
		return m.Name()
	case album.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AlbumMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case album.FieldName:
		return m.OldName(ctx)
	case album.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Album field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AlbumMutation) SetField(name string, value ent.Value) error {
	switch name {
	case album.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case album.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Album field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AlbumMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AlbumMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AlbumMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Album numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AlbumMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AlbumMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AlbumMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Album nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AlbumMutation) ResetField(name string) error {
	switch name {
	case album.FieldName:
		m.ResetName()
		return nil
	case album.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown Album field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AlbumMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.user != nil {
		edges = append(edges, album.EdgeUser)
	}
	if m.picture != nil {
		edges = append(edges, album.EdgePicture)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AlbumMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case album.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case album.EdgePicture:
		ids := make([]ent.Value, 0, len(m.picture))
		for id := range m.picture {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AlbumMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedpicture != nil {
		edges = append(edges, album.EdgePicture)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AlbumMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case album.EdgePicture:
		ids := make([]ent.Value, 0, len(m.removedpicture))
		for id := range m.removedpicture {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AlbumMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleareduser {
		edges = append(edges, album.EdgeUser)
	}
	if m.clearedpicture {
		edges = append(edges, album.EdgePicture)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AlbumMutation) EdgeCleared(name string) bool {
	switch name {
	case album.EdgeUser:
		return m.cleareduser
	case album.EdgePicture:
		return m.clearedpicture
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AlbumMutation) ClearEdge(name string) error {
	switch name {
	case album.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown Album unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AlbumMutation) ResetEdge(name string) error {
	switch name {
	case album.EdgeUser:
		m.ResetUser()
		return nil
	case album.EdgePicture:
		m.ResetPicture()
		return nil
	}
	return fmt.Errorf("unknown Album edge %s", name)
}

// DeviceMutation represents an operation that mutates the Device nodes in the graph.
type DeviceMutation struct {
	config
	op            Op
	typ           string
	id            *int
	device_token  *string
	push_token    *string
	device_os     *device.DeviceOs
	clearedFields map[string]struct{}
	user          *int
	cleareduser   bool
	done          bool
	oldValue      func(context.Context) (*Device, error)
	predicates    []predicate.Device
}

var _ ent.Mutation = (*DeviceMutation)(nil)

// deviceOption allows management of the mutation configuration using functional options.
type deviceOption func(*DeviceMutation)

// newDeviceMutation creates new mutation for the Device entity.
func newDeviceMutation(c config, op Op, opts ...deviceOption) *DeviceMutation {
	m := &DeviceMutation{
		config:        c,
		op:            op,
		typ:           TypeDevice,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDeviceID sets the ID field of the mutation.
func withDeviceID(id int) deviceOption {
	return func(m *DeviceMutation) {
		var (
			err   error
			once  sync.Once
			value *Device
		)
		m.oldValue = func(ctx context.Context) (*Device, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Device.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDevice sets the old Device of the mutation.
func withDevice(node *Device) deviceOption {
	return func(m *DeviceMutation) {
		m.oldValue = func(context.Context) (*Device, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DeviceMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DeviceMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Device entities.
func (m *DeviceMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *DeviceMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetDeviceToken sets the "device_token" field.
func (m *DeviceMutation) SetDeviceToken(s string) {
	m.device_token = &s
}

// DeviceToken returns the value of the "device_token" field in the mutation.
func (m *DeviceMutation) DeviceToken() (r string, exists bool) {
	v := m.device_token
	if v == nil {
		return
	}
	return *v, true
}

// OldDeviceToken returns the old "device_token" field's value of the Device entity.
// If the Device object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceMutation) OldDeviceToken(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDeviceToken is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDeviceToken requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeviceToken: %w", err)
	}
	return oldValue.DeviceToken, nil
}

// ResetDeviceToken resets all changes to the "device_token" field.
func (m *DeviceMutation) ResetDeviceToken() {
	m.device_token = nil
}

// SetPushToken sets the "push_token" field.
func (m *DeviceMutation) SetPushToken(s string) {
	m.push_token = &s
}

// PushToken returns the value of the "push_token" field in the mutation.
func (m *DeviceMutation) PushToken() (r string, exists bool) {
	v := m.push_token
	if v == nil {
		return
	}
	return *v, true
}

// OldPushToken returns the old "push_token" field's value of the Device entity.
// If the Device object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceMutation) OldPushToken(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPushToken is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPushToken requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPushToken: %w", err)
	}
	return oldValue.PushToken, nil
}

// ResetPushToken resets all changes to the "push_token" field.
func (m *DeviceMutation) ResetPushToken() {
	m.push_token = nil
}

// SetDeviceOs sets the "device_os" field.
func (m *DeviceMutation) SetDeviceOs(do device.DeviceOs) {
	m.device_os = &do
}

// DeviceOs returns the value of the "device_os" field in the mutation.
func (m *DeviceMutation) DeviceOs() (r device.DeviceOs, exists bool) {
	v := m.device_os
	if v == nil {
		return
	}
	return *v, true
}

// OldDeviceOs returns the old "device_os" field's value of the Device entity.
// If the Device object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceMutation) OldDeviceOs(ctx context.Context) (v device.DeviceOs, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDeviceOs is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDeviceOs requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeviceOs: %w", err)
	}
	return oldValue.DeviceOs, nil
}

// ResetDeviceOs resets all changes to the "device_os" field.
func (m *DeviceMutation) ResetDeviceOs() {
	m.device_os = nil
}

// SetUserID sets the "user" edge to the User entity by id.
func (m *DeviceMutation) SetUserID(id int) {
	m.user = &id
}

// ClearUser clears the "user" edge to the User entity.
func (m *DeviceMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *DeviceMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *DeviceMutation) UserID() (id int, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *DeviceMutation) UserIDs() (ids []int) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *DeviceMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the DeviceMutation builder.
func (m *DeviceMutation) Where(ps ...predicate.Device) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *DeviceMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Device).
func (m *DeviceMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DeviceMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.device_token != nil {
		fields = append(fields, device.FieldDeviceToken)
	}
	if m.push_token != nil {
		fields = append(fields, device.FieldPushToken)
	}
	if m.device_os != nil {
		fields = append(fields, device.FieldDeviceOs)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DeviceMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case device.FieldDeviceToken:
		return m.DeviceToken()
	case device.FieldPushToken:
		return m.PushToken()
	case device.FieldDeviceOs:
		return m.DeviceOs()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DeviceMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case device.FieldDeviceToken:
		return m.OldDeviceToken(ctx)
	case device.FieldPushToken:
		return m.OldPushToken(ctx)
	case device.FieldDeviceOs:
		return m.OldDeviceOs(ctx)
	}
	return nil, fmt.Errorf("unknown Device field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DeviceMutation) SetField(name string, value ent.Value) error {
	switch name {
	case device.FieldDeviceToken:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeviceToken(v)
		return nil
	case device.FieldPushToken:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPushToken(v)
		return nil
	case device.FieldDeviceOs:
		v, ok := value.(device.DeviceOs)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeviceOs(v)
		return nil
	}
	return fmt.Errorf("unknown Device field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DeviceMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DeviceMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DeviceMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Device numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DeviceMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DeviceMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DeviceMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Device nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DeviceMutation) ResetField(name string) error {
	switch name {
	case device.FieldDeviceToken:
		m.ResetDeviceToken()
		return nil
	case device.FieldPushToken:
		m.ResetPushToken()
		return nil
	case device.FieldDeviceOs:
		m.ResetDeviceOs()
		return nil
	}
	return fmt.Errorf("unknown Device field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DeviceMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.user != nil {
		edges = append(edges, device.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DeviceMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case device.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DeviceMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DeviceMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DeviceMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareduser {
		edges = append(edges, device.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DeviceMutation) EdgeCleared(name string) bool {
	switch name {
	case device.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DeviceMutation) ClearEdge(name string) error {
	switch name {
	case device.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown Device unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DeviceMutation) ResetEdge(name string) error {
	switch name {
	case device.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown Device edge %s", name)
}

// NotificationConfigMutation represents an operation that mutates the NotificationConfig nodes in the graph.
type NotificationConfigMutation struct {
	config
	op                       Op
	typ                      string
	id                       *int
	monday                   *bool
	tuesday                  *bool
	wednesday                *bool
	thursday                 *bool
	friday                   *bool
	saturday                 *bool
	sunday                   *bool
	preferred_time_hour      *int
	addpreferred_time_hour   *int
	preferred_time_minute    *int
	addpreferred_time_minute *int
	last_notified_at         *time.Time
	is_activated             *bool
	clearedFields            map[string]struct{}
	user                     *int
	cleareduser              bool
	done                     bool
	oldValue                 func(context.Context) (*NotificationConfig, error)
	predicates               []predicate.NotificationConfig
}

var _ ent.Mutation = (*NotificationConfigMutation)(nil)

// notificationconfigOption allows management of the mutation configuration using functional options.
type notificationconfigOption func(*NotificationConfigMutation)

// newNotificationConfigMutation creates new mutation for the NotificationConfig entity.
func newNotificationConfigMutation(c config, op Op, opts ...notificationconfigOption) *NotificationConfigMutation {
	m := &NotificationConfigMutation{
		config:        c,
		op:            op,
		typ:           TypeNotificationConfig,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withNotificationConfigID sets the ID field of the mutation.
func withNotificationConfigID(id int) notificationconfigOption {
	return func(m *NotificationConfigMutation) {
		var (
			err   error
			once  sync.Once
			value *NotificationConfig
		)
		m.oldValue = func(ctx context.Context) (*NotificationConfig, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().NotificationConfig.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withNotificationConfig sets the old NotificationConfig of the mutation.
func withNotificationConfig(node *NotificationConfig) notificationconfigOption {
	return func(m *NotificationConfigMutation) {
		m.oldValue = func(context.Context) (*NotificationConfig, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m NotificationConfigMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m NotificationConfigMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of NotificationConfig entities.
func (m *NotificationConfigMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *NotificationConfigMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetMonday sets the "monday" field.
func (m *NotificationConfigMutation) SetMonday(b bool) {
	m.monday = &b
}

// Monday returns the value of the "monday" field in the mutation.
func (m *NotificationConfigMutation) Monday() (r bool, exists bool) {
	v := m.monday
	if v == nil {
		return
	}
	return *v, true
}

// OldMonday returns the old "monday" field's value of the NotificationConfig entity.
// If the NotificationConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationConfigMutation) OldMonday(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldMonday is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldMonday requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMonday: %w", err)
	}
	return oldValue.Monday, nil
}

// ResetMonday resets all changes to the "monday" field.
func (m *NotificationConfigMutation) ResetMonday() {
	m.monday = nil
}

// SetTuesday sets the "tuesday" field.
func (m *NotificationConfigMutation) SetTuesday(b bool) {
	m.tuesday = &b
}

// Tuesday returns the value of the "tuesday" field in the mutation.
func (m *NotificationConfigMutation) Tuesday() (r bool, exists bool) {
	v := m.tuesday
	if v == nil {
		return
	}
	return *v, true
}

// OldTuesday returns the old "tuesday" field's value of the NotificationConfig entity.
// If the NotificationConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationConfigMutation) OldTuesday(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTuesday is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTuesday requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTuesday: %w", err)
	}
	return oldValue.Tuesday, nil
}

// ResetTuesday resets all changes to the "tuesday" field.
func (m *NotificationConfigMutation) ResetTuesday() {
	m.tuesday = nil
}

// SetWednesday sets the "wednesday" field.
func (m *NotificationConfigMutation) SetWednesday(b bool) {
	m.wednesday = &b
}

// Wednesday returns the value of the "wednesday" field in the mutation.
func (m *NotificationConfigMutation) Wednesday() (r bool, exists bool) {
	v := m.wednesday
	if v == nil {
		return
	}
	return *v, true
}

// OldWednesday returns the old "wednesday" field's value of the NotificationConfig entity.
// If the NotificationConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationConfigMutation) OldWednesday(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldWednesday is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldWednesday requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWednesday: %w", err)
	}
	return oldValue.Wednesday, nil
}

// ResetWednesday resets all changes to the "wednesday" field.
func (m *NotificationConfigMutation) ResetWednesday() {
	m.wednesday = nil
}

// SetThursday sets the "thursday" field.
func (m *NotificationConfigMutation) SetThursday(b bool) {
	m.thursday = &b
}

// Thursday returns the value of the "thursday" field in the mutation.
func (m *NotificationConfigMutation) Thursday() (r bool, exists bool) {
	v := m.thursday
	if v == nil {
		return
	}
	return *v, true
}

// OldThursday returns the old "thursday" field's value of the NotificationConfig entity.
// If the NotificationConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationConfigMutation) OldThursday(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldThursday is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldThursday requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldThursday: %w", err)
	}
	return oldValue.Thursday, nil
}

// ResetThursday resets all changes to the "thursday" field.
func (m *NotificationConfigMutation) ResetThursday() {
	m.thursday = nil
}

// SetFriday sets the "friday" field.
func (m *NotificationConfigMutation) SetFriday(b bool) {
	m.friday = &b
}

// Friday returns the value of the "friday" field in the mutation.
func (m *NotificationConfigMutation) Friday() (r bool, exists bool) {
	v := m.friday
	if v == nil {
		return
	}
	return *v, true
}

// OldFriday returns the old "friday" field's value of the NotificationConfig entity.
// If the NotificationConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationConfigMutation) OldFriday(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldFriday is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldFriday requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFriday: %w", err)
	}
	return oldValue.Friday, nil
}

// ResetFriday resets all changes to the "friday" field.
func (m *NotificationConfigMutation) ResetFriday() {
	m.friday = nil
}

// SetSaturday sets the "saturday" field.
func (m *NotificationConfigMutation) SetSaturday(b bool) {
	m.saturday = &b
}

// Saturday returns the value of the "saturday" field in the mutation.
func (m *NotificationConfigMutation) Saturday() (r bool, exists bool) {
	v := m.saturday
	if v == nil {
		return
	}
	return *v, true
}

// OldSaturday returns the old "saturday" field's value of the NotificationConfig entity.
// If the NotificationConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationConfigMutation) OldSaturday(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSaturday is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSaturday requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSaturday: %w", err)
	}
	return oldValue.Saturday, nil
}

// ResetSaturday resets all changes to the "saturday" field.
func (m *NotificationConfigMutation) ResetSaturday() {
	m.saturday = nil
}

// SetSunday sets the "sunday" field.
func (m *NotificationConfigMutation) SetSunday(b bool) {
	m.sunday = &b
}

// Sunday returns the value of the "sunday" field in the mutation.
func (m *NotificationConfigMutation) Sunday() (r bool, exists bool) {
	v := m.sunday
	if v == nil {
		return
	}
	return *v, true
}

// OldSunday returns the old "sunday" field's value of the NotificationConfig entity.
// If the NotificationConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationConfigMutation) OldSunday(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSunday is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSunday requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSunday: %w", err)
	}
	return oldValue.Sunday, nil
}

// ResetSunday resets all changes to the "sunday" field.
func (m *NotificationConfigMutation) ResetSunday() {
	m.sunday = nil
}

// SetPreferredTimeHour sets the "preferred_time_hour" field.
func (m *NotificationConfigMutation) SetPreferredTimeHour(i int) {
	m.preferred_time_hour = &i
	m.addpreferred_time_hour = nil
}

// PreferredTimeHour returns the value of the "preferred_time_hour" field in the mutation.
func (m *NotificationConfigMutation) PreferredTimeHour() (r int, exists bool) {
	v := m.preferred_time_hour
	if v == nil {
		return
	}
	return *v, true
}

// OldPreferredTimeHour returns the old "preferred_time_hour" field's value of the NotificationConfig entity.
// If the NotificationConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationConfigMutation) OldPreferredTimeHour(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPreferredTimeHour is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPreferredTimeHour requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPreferredTimeHour: %w", err)
	}
	return oldValue.PreferredTimeHour, nil
}

// AddPreferredTimeHour adds i to the "preferred_time_hour" field.
func (m *NotificationConfigMutation) AddPreferredTimeHour(i int) {
	if m.addpreferred_time_hour != nil {
		*m.addpreferred_time_hour += i
	} else {
		m.addpreferred_time_hour = &i
	}
}

// AddedPreferredTimeHour returns the value that was added to the "preferred_time_hour" field in this mutation.
func (m *NotificationConfigMutation) AddedPreferredTimeHour() (r int, exists bool) {
	v := m.addpreferred_time_hour
	if v == nil {
		return
	}
	return *v, true
}

// ClearPreferredTimeHour clears the value of the "preferred_time_hour" field.
func (m *NotificationConfigMutation) ClearPreferredTimeHour() {
	m.preferred_time_hour = nil
	m.addpreferred_time_hour = nil
	m.clearedFields[notificationconfig.FieldPreferredTimeHour] = struct{}{}
}

// PreferredTimeHourCleared returns if the "preferred_time_hour" field was cleared in this mutation.
func (m *NotificationConfigMutation) PreferredTimeHourCleared() bool {
	_, ok := m.clearedFields[notificationconfig.FieldPreferredTimeHour]
	return ok
}

// ResetPreferredTimeHour resets all changes to the "preferred_time_hour" field.
func (m *NotificationConfigMutation) ResetPreferredTimeHour() {
	m.preferred_time_hour = nil
	m.addpreferred_time_hour = nil
	delete(m.clearedFields, notificationconfig.FieldPreferredTimeHour)
}

// SetPreferredTimeMinute sets the "preferred_time_minute" field.
func (m *NotificationConfigMutation) SetPreferredTimeMinute(i int) {
	m.preferred_time_minute = &i
	m.addpreferred_time_minute = nil
}

// PreferredTimeMinute returns the value of the "preferred_time_minute" field in the mutation.
func (m *NotificationConfigMutation) PreferredTimeMinute() (r int, exists bool) {
	v := m.preferred_time_minute
	if v == nil {
		return
	}
	return *v, true
}

// OldPreferredTimeMinute returns the old "preferred_time_minute" field's value of the NotificationConfig entity.
// If the NotificationConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationConfigMutation) OldPreferredTimeMinute(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPreferredTimeMinute is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPreferredTimeMinute requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPreferredTimeMinute: %w", err)
	}
	return oldValue.PreferredTimeMinute, nil
}

// AddPreferredTimeMinute adds i to the "preferred_time_minute" field.
func (m *NotificationConfigMutation) AddPreferredTimeMinute(i int) {
	if m.addpreferred_time_minute != nil {
		*m.addpreferred_time_minute += i
	} else {
		m.addpreferred_time_minute = &i
	}
}

// AddedPreferredTimeMinute returns the value that was added to the "preferred_time_minute" field in this mutation.
func (m *NotificationConfigMutation) AddedPreferredTimeMinute() (r int, exists bool) {
	v := m.addpreferred_time_minute
	if v == nil {
		return
	}
	return *v, true
}

// ClearPreferredTimeMinute clears the value of the "preferred_time_minute" field.
func (m *NotificationConfigMutation) ClearPreferredTimeMinute() {
	m.preferred_time_minute = nil
	m.addpreferred_time_minute = nil
	m.clearedFields[notificationconfig.FieldPreferredTimeMinute] = struct{}{}
}

// PreferredTimeMinuteCleared returns if the "preferred_time_minute" field was cleared in this mutation.
func (m *NotificationConfigMutation) PreferredTimeMinuteCleared() bool {
	_, ok := m.clearedFields[notificationconfig.FieldPreferredTimeMinute]
	return ok
}

// ResetPreferredTimeMinute resets all changes to the "preferred_time_minute" field.
func (m *NotificationConfigMutation) ResetPreferredTimeMinute() {
	m.preferred_time_minute = nil
	m.addpreferred_time_minute = nil
	delete(m.clearedFields, notificationconfig.FieldPreferredTimeMinute)
}

// SetLastNotifiedAt sets the "last_notified_at" field.
func (m *NotificationConfigMutation) SetLastNotifiedAt(t time.Time) {
	m.last_notified_at = &t
}

// LastNotifiedAt returns the value of the "last_notified_at" field in the mutation.
func (m *NotificationConfigMutation) LastNotifiedAt() (r time.Time, exists bool) {
	v := m.last_notified_at
	if v == nil {
		return
	}
	return *v, true
}

// OldLastNotifiedAt returns the old "last_notified_at" field's value of the NotificationConfig entity.
// If the NotificationConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationConfigMutation) OldLastNotifiedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldLastNotifiedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldLastNotifiedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastNotifiedAt: %w", err)
	}
	return oldValue.LastNotifiedAt, nil
}

// ClearLastNotifiedAt clears the value of the "last_notified_at" field.
func (m *NotificationConfigMutation) ClearLastNotifiedAt() {
	m.last_notified_at = nil
	m.clearedFields[notificationconfig.FieldLastNotifiedAt] = struct{}{}
}

// LastNotifiedAtCleared returns if the "last_notified_at" field was cleared in this mutation.
func (m *NotificationConfigMutation) LastNotifiedAtCleared() bool {
	_, ok := m.clearedFields[notificationconfig.FieldLastNotifiedAt]
	return ok
}

// ResetLastNotifiedAt resets all changes to the "last_notified_at" field.
func (m *NotificationConfigMutation) ResetLastNotifiedAt() {
	m.last_notified_at = nil
	delete(m.clearedFields, notificationconfig.FieldLastNotifiedAt)
}

// SetIsActivated sets the "is_activated" field.
func (m *NotificationConfigMutation) SetIsActivated(b bool) {
	m.is_activated = &b
}

// IsActivated returns the value of the "is_activated" field in the mutation.
func (m *NotificationConfigMutation) IsActivated() (r bool, exists bool) {
	v := m.is_activated
	if v == nil {
		return
	}
	return *v, true
}

// OldIsActivated returns the old "is_activated" field's value of the NotificationConfig entity.
// If the NotificationConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationConfigMutation) OldIsActivated(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldIsActivated is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldIsActivated requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsActivated: %w", err)
	}
	return oldValue.IsActivated, nil
}

// ResetIsActivated resets all changes to the "is_activated" field.
func (m *NotificationConfigMutation) ResetIsActivated() {
	m.is_activated = nil
}

// SetUserID sets the "user" edge to the User entity by id.
func (m *NotificationConfigMutation) SetUserID(id int) {
	m.user = &id
}

// ClearUser clears the "user" edge to the User entity.
func (m *NotificationConfigMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *NotificationConfigMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *NotificationConfigMutation) UserID() (id int, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *NotificationConfigMutation) UserIDs() (ids []int) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *NotificationConfigMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the NotificationConfigMutation builder.
func (m *NotificationConfigMutation) Where(ps ...predicate.NotificationConfig) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *NotificationConfigMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (NotificationConfig).
func (m *NotificationConfigMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *NotificationConfigMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.monday != nil {
		fields = append(fields, notificationconfig.FieldMonday)
	}
	if m.tuesday != nil {
		fields = append(fields, notificationconfig.FieldTuesday)
	}
	if m.wednesday != nil {
		fields = append(fields, notificationconfig.FieldWednesday)
	}
	if m.thursday != nil {
		fields = append(fields, notificationconfig.FieldThursday)
	}
	if m.friday != nil {
		fields = append(fields, notificationconfig.FieldFriday)
	}
	if m.saturday != nil {
		fields = append(fields, notificationconfig.FieldSaturday)
	}
	if m.sunday != nil {
		fields = append(fields, notificationconfig.FieldSunday)
	}
	if m.preferred_time_hour != nil {
		fields = append(fields, notificationconfig.FieldPreferredTimeHour)
	}
	if m.preferred_time_minute != nil {
		fields = append(fields, notificationconfig.FieldPreferredTimeMinute)
	}
	if m.last_notified_at != nil {
		fields = append(fields, notificationconfig.FieldLastNotifiedAt)
	}
	if m.is_activated != nil {
		fields = append(fields, notificationconfig.FieldIsActivated)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *NotificationConfigMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case notificationconfig.FieldMonday:
		return m.Monday()
	case notificationconfig.FieldTuesday:
		return m.Tuesday()
	case notificationconfig.FieldWednesday:
		return m.Wednesday()
	case notificationconfig.FieldThursday:
		return m.Thursday()
	case notificationconfig.FieldFriday:
		return m.Friday()
	case notificationconfig.FieldSaturday:
		return m.Saturday()
	case notificationconfig.FieldSunday:
		return m.Sunday()
	case notificationconfig.FieldPreferredTimeHour:
		return m.PreferredTimeHour()
	case notificationconfig.FieldPreferredTimeMinute:
		return m.PreferredTimeMinute()
	case notificationconfig.FieldLastNotifiedAt:
		return m.LastNotifiedAt()
	case notificationconfig.FieldIsActivated:
		return m.IsActivated()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *NotificationConfigMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case notificationconfig.FieldMonday:
		return m.OldMonday(ctx)
	case notificationconfig.FieldTuesday:
		return m.OldTuesday(ctx)
	case notificationconfig.FieldWednesday:
		return m.OldWednesday(ctx)
	case notificationconfig.FieldThursday:
		return m.OldThursday(ctx)
	case notificationconfig.FieldFriday:
		return m.OldFriday(ctx)
	case notificationconfig.FieldSaturday:
		return m.OldSaturday(ctx)
	case notificationconfig.FieldSunday:
		return m.OldSunday(ctx)
	case notificationconfig.FieldPreferredTimeHour:
		return m.OldPreferredTimeHour(ctx)
	case notificationconfig.FieldPreferredTimeMinute:
		return m.OldPreferredTimeMinute(ctx)
	case notificationconfig.FieldLastNotifiedAt:
		return m.OldLastNotifiedAt(ctx)
	case notificationconfig.FieldIsActivated:
		return m.OldIsActivated(ctx)
	}
	return nil, fmt.Errorf("unknown NotificationConfig field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NotificationConfigMutation) SetField(name string, value ent.Value) error {
	switch name {
	case notificationconfig.FieldMonday:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMonday(v)
		return nil
	case notificationconfig.FieldTuesday:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTuesday(v)
		return nil
	case notificationconfig.FieldWednesday:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWednesday(v)
		return nil
	case notificationconfig.FieldThursday:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetThursday(v)
		return nil
	case notificationconfig.FieldFriday:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFriday(v)
		return nil
	case notificationconfig.FieldSaturday:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSaturday(v)
		return nil
	case notificationconfig.FieldSunday:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSunday(v)
		return nil
	case notificationconfig.FieldPreferredTimeHour:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPreferredTimeHour(v)
		return nil
	case notificationconfig.FieldPreferredTimeMinute:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPreferredTimeMinute(v)
		return nil
	case notificationconfig.FieldLastNotifiedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastNotifiedAt(v)
		return nil
	case notificationconfig.FieldIsActivated:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsActivated(v)
		return nil
	}
	return fmt.Errorf("unknown NotificationConfig field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *NotificationConfigMutation) AddedFields() []string {
	var fields []string
	if m.addpreferred_time_hour != nil {
		fields = append(fields, notificationconfig.FieldPreferredTimeHour)
	}
	if m.addpreferred_time_minute != nil {
		fields = append(fields, notificationconfig.FieldPreferredTimeMinute)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *NotificationConfigMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case notificationconfig.FieldPreferredTimeHour:
		return m.AddedPreferredTimeHour()
	case notificationconfig.FieldPreferredTimeMinute:
		return m.AddedPreferredTimeMinute()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NotificationConfigMutation) AddField(name string, value ent.Value) error {
	switch name {
	case notificationconfig.FieldPreferredTimeHour:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPreferredTimeHour(v)
		return nil
	case notificationconfig.FieldPreferredTimeMinute:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPreferredTimeMinute(v)
		return nil
	}
	return fmt.Errorf("unknown NotificationConfig numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *NotificationConfigMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(notificationconfig.FieldPreferredTimeHour) {
		fields = append(fields, notificationconfig.FieldPreferredTimeHour)
	}
	if m.FieldCleared(notificationconfig.FieldPreferredTimeMinute) {
		fields = append(fields, notificationconfig.FieldPreferredTimeMinute)
	}
	if m.FieldCleared(notificationconfig.FieldLastNotifiedAt) {
		fields = append(fields, notificationconfig.FieldLastNotifiedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *NotificationConfigMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *NotificationConfigMutation) ClearField(name string) error {
	switch name {
	case notificationconfig.FieldPreferredTimeHour:
		m.ClearPreferredTimeHour()
		return nil
	case notificationconfig.FieldPreferredTimeMinute:
		m.ClearPreferredTimeMinute()
		return nil
	case notificationconfig.FieldLastNotifiedAt:
		m.ClearLastNotifiedAt()
		return nil
	}
	return fmt.Errorf("unknown NotificationConfig nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *NotificationConfigMutation) ResetField(name string) error {
	switch name {
	case notificationconfig.FieldMonday:
		m.ResetMonday()
		return nil
	case notificationconfig.FieldTuesday:
		m.ResetTuesday()
		return nil
	case notificationconfig.FieldWednesday:
		m.ResetWednesday()
		return nil
	case notificationconfig.FieldThursday:
		m.ResetThursday()
		return nil
	case notificationconfig.FieldFriday:
		m.ResetFriday()
		return nil
	case notificationconfig.FieldSaturday:
		m.ResetSaturday()
		return nil
	case notificationconfig.FieldSunday:
		m.ResetSunday()
		return nil
	case notificationconfig.FieldPreferredTimeHour:
		m.ResetPreferredTimeHour()
		return nil
	case notificationconfig.FieldPreferredTimeMinute:
		m.ResetPreferredTimeMinute()
		return nil
	case notificationconfig.FieldLastNotifiedAt:
		m.ResetLastNotifiedAt()
		return nil
	case notificationconfig.FieldIsActivated:
		m.ResetIsActivated()
		return nil
	}
	return fmt.Errorf("unknown NotificationConfig field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *NotificationConfigMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.user != nil {
		edges = append(edges, notificationconfig.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *NotificationConfigMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case notificationconfig.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *NotificationConfigMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *NotificationConfigMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *NotificationConfigMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareduser {
		edges = append(edges, notificationconfig.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *NotificationConfigMutation) EdgeCleared(name string) bool {
	switch name {
	case notificationconfig.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *NotificationConfigMutation) ClearEdge(name string) error {
	switch name {
	case notificationconfig.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown NotificationConfig unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *NotificationConfigMutation) ResetEdge(name string) error {
	switch name {
	case notificationconfig.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown NotificationConfig edge %s", name)
}

// PictureMutation represents an operation that mutates the Picture nodes in the graph.
type PictureMutation struct {
	config
	op            Op
	typ           string
	id            *int
	body_part     *string
	key           *string
	created_at    *time.Time
	clearedFields map[string]struct{}
	album         *int
	clearedalbum  bool
	user          *int
	cleareduser   bool
	done          bool
	oldValue      func(context.Context) (*Picture, error)
	predicates    []predicate.Picture
}

var _ ent.Mutation = (*PictureMutation)(nil)

// pictureOption allows management of the mutation configuration using functional options.
type pictureOption func(*PictureMutation)

// newPictureMutation creates new mutation for the Picture entity.
func newPictureMutation(c config, op Op, opts ...pictureOption) *PictureMutation {
	m := &PictureMutation{
		config:        c,
		op:            op,
		typ:           TypePicture,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPictureID sets the ID field of the mutation.
func withPictureID(id int) pictureOption {
	return func(m *PictureMutation) {
		var (
			err   error
			once  sync.Once
			value *Picture
		)
		m.oldValue = func(ctx context.Context) (*Picture, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Picture.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPicture sets the old Picture of the mutation.
func withPicture(node *Picture) pictureOption {
	return func(m *PictureMutation) {
		m.oldValue = func(context.Context) (*Picture, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PictureMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PictureMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PictureMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetBodyPart sets the "body_part" field.
func (m *PictureMutation) SetBodyPart(s string) {
	m.body_part = &s
}

// BodyPart returns the value of the "body_part" field in the mutation.
func (m *PictureMutation) BodyPart() (r string, exists bool) {
	v := m.body_part
	if v == nil {
		return
	}
	return *v, true
}

// OldBodyPart returns the old "body_part" field's value of the Picture entity.
// If the Picture object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PictureMutation) OldBodyPart(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldBodyPart is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldBodyPart requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBodyPart: %w", err)
	}
	return oldValue.BodyPart, nil
}

// ResetBodyPart resets all changes to the "body_part" field.
func (m *PictureMutation) ResetBodyPart() {
	m.body_part = nil
}

// SetKey sets the "key" field.
func (m *PictureMutation) SetKey(s string) {
	m.key = &s
}

// Key returns the value of the "key" field in the mutation.
func (m *PictureMutation) Key() (r string, exists bool) {
	v := m.key
	if v == nil {
		return
	}
	return *v, true
}

// OldKey returns the old "key" field's value of the Picture entity.
// If the Picture object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PictureMutation) OldKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKey: %w", err)
	}
	return oldValue.Key, nil
}

// ResetKey resets all changes to the "key" field.
func (m *PictureMutation) ResetKey() {
	m.key = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *PictureMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *PictureMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Picture entity.
// If the Picture object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PictureMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *PictureMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetAlbumID sets the "album" edge to the Album entity by id.
func (m *PictureMutation) SetAlbumID(id int) {
	m.album = &id
}

// ClearAlbum clears the "album" edge to the Album entity.
func (m *PictureMutation) ClearAlbum() {
	m.clearedalbum = true
}

// AlbumCleared reports if the "album" edge to the Album entity was cleared.
func (m *PictureMutation) AlbumCleared() bool {
	return m.clearedalbum
}

// AlbumID returns the "album" edge ID in the mutation.
func (m *PictureMutation) AlbumID() (id int, exists bool) {
	if m.album != nil {
		return *m.album, true
	}
	return
}

// AlbumIDs returns the "album" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AlbumID instead. It exists only for internal usage by the builders.
func (m *PictureMutation) AlbumIDs() (ids []int) {
	if id := m.album; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAlbum resets all changes to the "album" edge.
func (m *PictureMutation) ResetAlbum() {
	m.album = nil
	m.clearedalbum = false
}

// SetUserID sets the "user" edge to the User entity by id.
func (m *PictureMutation) SetUserID(id int) {
	m.user = &id
}

// ClearUser clears the "user" edge to the User entity.
func (m *PictureMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *PictureMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *PictureMutation) UserID() (id int, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *PictureMutation) UserIDs() (ids []int) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *PictureMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the PictureMutation builder.
func (m *PictureMutation) Where(ps ...predicate.Picture) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *PictureMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Picture).
func (m *PictureMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PictureMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.body_part != nil {
		fields = append(fields, picture.FieldBodyPart)
	}
	if m.key != nil {
		fields = append(fields, picture.FieldKey)
	}
	if m.created_at != nil {
		fields = append(fields, picture.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PictureMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case picture.FieldBodyPart:
		return m.BodyPart()
	case picture.FieldKey:
		return m.Key()
	case picture.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PictureMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case picture.FieldBodyPart:
		return m.OldBodyPart(ctx)
	case picture.FieldKey:
		return m.OldKey(ctx)
	case picture.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Picture field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PictureMutation) SetField(name string, value ent.Value) error {
	switch name {
	case picture.FieldBodyPart:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBodyPart(v)
		return nil
	case picture.FieldKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKey(v)
		return nil
	case picture.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Picture field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PictureMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PictureMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PictureMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Picture numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PictureMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PictureMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PictureMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Picture nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PictureMutation) ResetField(name string) error {
	switch name {
	case picture.FieldBodyPart:
		m.ResetBodyPart()
		return nil
	case picture.FieldKey:
		m.ResetKey()
		return nil
	case picture.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown Picture field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PictureMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.album != nil {
		edges = append(edges, picture.EdgeAlbum)
	}
	if m.user != nil {
		edges = append(edges, picture.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PictureMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case picture.EdgeAlbum:
		if id := m.album; id != nil {
			return []ent.Value{*id}
		}
	case picture.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PictureMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PictureMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PictureMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedalbum {
		edges = append(edges, picture.EdgeAlbum)
	}
	if m.cleareduser {
		edges = append(edges, picture.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PictureMutation) EdgeCleared(name string) bool {
	switch name {
	case picture.EdgeAlbum:
		return m.clearedalbum
	case picture.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PictureMutation) ClearEdge(name string) error {
	switch name {
	case picture.EdgeAlbum:
		m.ClearAlbum()
		return nil
	case picture.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown Picture unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PictureMutation) ResetEdge(name string) error {
	switch name {
	case picture.EdgeAlbum:
		m.ResetAlbum()
		return nil
	case picture.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown Picture edge %s", name)
}

// UserMutation represents an operation that mutates the User nodes in the graph.
type UserMutation struct {
	config
	op                         Op
	typ                        string
	id                         *int
	nickname                   *string
	motto                      *string
	height                     *int
	addheight                  *int
	weight                     *int
	addweight                  *int
	kind                       *user.Kind
	created_at                 *time.Time
	clearedFields              map[string]struct{}
	devices                    map[int]struct{}
	removeddevices             map[int]struct{}
	cleareddevices             bool
	notification_config        map[int]struct{}
	removednotification_config map[int]struct{}
	clearednotification_config bool
	album                      map[int]struct{}
	removedalbum               map[int]struct{}
	clearedalbum               bool
	picture                    map[int]struct{}
	removedpicture             map[int]struct{}
	clearedpicture             bool
	done                       bool
	oldValue                   func(context.Context) (*User, error)
	predicates                 []predicate.User
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows management of the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for the User entity.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the ID field of the mutation.
func withUserID(id int) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of User entities.
func (m *UserMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetNickname sets the "nickname" field.
func (m *UserMutation) SetNickname(s string) {
	m.nickname = &s
}

// Nickname returns the value of the "nickname" field in the mutation.
func (m *UserMutation) Nickname() (r string, exists bool) {
	v := m.nickname
	if v == nil {
		return
	}
	return *v, true
}

// OldNickname returns the old "nickname" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldNickname(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldNickname is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldNickname requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNickname: %w", err)
	}
	return oldValue.Nickname, nil
}

// ResetNickname resets all changes to the "nickname" field.
func (m *UserMutation) ResetNickname() {
	m.nickname = nil
}

// SetMotto sets the "motto" field.
func (m *UserMutation) SetMotto(s string) {
	m.motto = &s
}

// Motto returns the value of the "motto" field in the mutation.
func (m *UserMutation) Motto() (r string, exists bool) {
	v := m.motto
	if v == nil {
		return
	}
	return *v, true
}

// OldMotto returns the old "motto" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldMotto(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldMotto is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldMotto requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMotto: %w", err)
	}
	return oldValue.Motto, nil
}

// ResetMotto resets all changes to the "motto" field.
func (m *UserMutation) ResetMotto() {
	m.motto = nil
}

// SetHeight sets the "height" field.
func (m *UserMutation) SetHeight(i int) {
	m.height = &i
	m.addheight = nil
}

// Height returns the value of the "height" field in the mutation.
func (m *UserMutation) Height() (r int, exists bool) {
	v := m.height
	if v == nil {
		return
	}
	return *v, true
}

// OldHeight returns the old "height" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldHeight(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldHeight is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldHeight requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHeight: %w", err)
	}
	return oldValue.Height, nil
}

// AddHeight adds i to the "height" field.
func (m *UserMutation) AddHeight(i int) {
	if m.addheight != nil {
		*m.addheight += i
	} else {
		m.addheight = &i
	}
}

// AddedHeight returns the value that was added to the "height" field in this mutation.
func (m *UserMutation) AddedHeight() (r int, exists bool) {
	v := m.addheight
	if v == nil {
		return
	}
	return *v, true
}

// ClearHeight clears the value of the "height" field.
func (m *UserMutation) ClearHeight() {
	m.height = nil
	m.addheight = nil
	m.clearedFields[user.FieldHeight] = struct{}{}
}

// HeightCleared returns if the "height" field was cleared in this mutation.
func (m *UserMutation) HeightCleared() bool {
	_, ok := m.clearedFields[user.FieldHeight]
	return ok
}

// ResetHeight resets all changes to the "height" field.
func (m *UserMutation) ResetHeight() {
	m.height = nil
	m.addheight = nil
	delete(m.clearedFields, user.FieldHeight)
}

// SetWeight sets the "weight" field.
func (m *UserMutation) SetWeight(i int) {
	m.weight = &i
	m.addweight = nil
}

// Weight returns the value of the "weight" field in the mutation.
func (m *UserMutation) Weight() (r int, exists bool) {
	v := m.weight
	if v == nil {
		return
	}
	return *v, true
}

// OldWeight returns the old "weight" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldWeight(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldWeight is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldWeight requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWeight: %w", err)
	}
	return oldValue.Weight, nil
}

// AddWeight adds i to the "weight" field.
func (m *UserMutation) AddWeight(i int) {
	if m.addweight != nil {
		*m.addweight += i
	} else {
		m.addweight = &i
	}
}

// AddedWeight returns the value that was added to the "weight" field in this mutation.
func (m *UserMutation) AddedWeight() (r int, exists bool) {
	v := m.addweight
	if v == nil {
		return
	}
	return *v, true
}

// ClearWeight clears the value of the "weight" field.
func (m *UserMutation) ClearWeight() {
	m.weight = nil
	m.addweight = nil
	m.clearedFields[user.FieldWeight] = struct{}{}
}

// WeightCleared returns if the "weight" field was cleared in this mutation.
func (m *UserMutation) WeightCleared() bool {
	_, ok := m.clearedFields[user.FieldWeight]
	return ok
}

// ResetWeight resets all changes to the "weight" field.
func (m *UserMutation) ResetWeight() {
	m.weight = nil
	m.addweight = nil
	delete(m.clearedFields, user.FieldWeight)
}

// SetKind sets the "kind" field.
func (m *UserMutation) SetKind(u user.Kind) {
	m.kind = &u
}

// Kind returns the value of the "kind" field in the mutation.
func (m *UserMutation) Kind() (r user.Kind, exists bool) {
	v := m.kind
	if v == nil {
		return
	}
	return *v, true
}

// OldKind returns the old "kind" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldKind(ctx context.Context) (v user.Kind, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldKind is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldKind requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKind: %w", err)
	}
	return oldValue.Kind, nil
}

// ResetKind resets all changes to the "kind" field.
func (m *UserMutation) ResetKind() {
	m.kind = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *UserMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UserMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UserMutation) ResetCreatedAt() {
	m.created_at = nil
}

// AddDeviceIDs adds the "devices" edge to the Device entity by ids.
func (m *UserMutation) AddDeviceIDs(ids ...int) {
	if m.devices == nil {
		m.devices = make(map[int]struct{})
	}
	for i := range ids {
		m.devices[ids[i]] = struct{}{}
	}
}

// ClearDevices clears the "devices" edge to the Device entity.
func (m *UserMutation) ClearDevices() {
	m.cleareddevices = true
}

// DevicesCleared reports if the "devices" edge to the Device entity was cleared.
func (m *UserMutation) DevicesCleared() bool {
	return m.cleareddevices
}

// RemoveDeviceIDs removes the "devices" edge to the Device entity by IDs.
func (m *UserMutation) RemoveDeviceIDs(ids ...int) {
	if m.removeddevices == nil {
		m.removeddevices = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.devices, ids[i])
		m.removeddevices[ids[i]] = struct{}{}
	}
}

// RemovedDevices returns the removed IDs of the "devices" edge to the Device entity.
func (m *UserMutation) RemovedDevicesIDs() (ids []int) {
	for id := range m.removeddevices {
		ids = append(ids, id)
	}
	return
}

// DevicesIDs returns the "devices" edge IDs in the mutation.
func (m *UserMutation) DevicesIDs() (ids []int) {
	for id := range m.devices {
		ids = append(ids, id)
	}
	return
}

// ResetDevices resets all changes to the "devices" edge.
func (m *UserMutation) ResetDevices() {
	m.devices = nil
	m.cleareddevices = false
	m.removeddevices = nil
}

// AddNotificationConfigIDs adds the "notification_config" edge to the NotificationConfig entity by ids.
func (m *UserMutation) AddNotificationConfigIDs(ids ...int) {
	if m.notification_config == nil {
		m.notification_config = make(map[int]struct{})
	}
	for i := range ids {
		m.notification_config[ids[i]] = struct{}{}
	}
}

// ClearNotificationConfig clears the "notification_config" edge to the NotificationConfig entity.
func (m *UserMutation) ClearNotificationConfig() {
	m.clearednotification_config = true
}

// NotificationConfigCleared reports if the "notification_config" edge to the NotificationConfig entity was cleared.
func (m *UserMutation) NotificationConfigCleared() bool {
	return m.clearednotification_config
}

// RemoveNotificationConfigIDs removes the "notification_config" edge to the NotificationConfig entity by IDs.
func (m *UserMutation) RemoveNotificationConfigIDs(ids ...int) {
	if m.removednotification_config == nil {
		m.removednotification_config = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.notification_config, ids[i])
		m.removednotification_config[ids[i]] = struct{}{}
	}
}

// RemovedNotificationConfig returns the removed IDs of the "notification_config" edge to the NotificationConfig entity.
func (m *UserMutation) RemovedNotificationConfigIDs() (ids []int) {
	for id := range m.removednotification_config {
		ids = append(ids, id)
	}
	return
}

// NotificationConfigIDs returns the "notification_config" edge IDs in the mutation.
func (m *UserMutation) NotificationConfigIDs() (ids []int) {
	for id := range m.notification_config {
		ids = append(ids, id)
	}
	return
}

// ResetNotificationConfig resets all changes to the "notification_config" edge.
func (m *UserMutation) ResetNotificationConfig() {
	m.notification_config = nil
	m.clearednotification_config = false
	m.removednotification_config = nil
}

// AddAlbumIDs adds the "album" edge to the Album entity by ids.
func (m *UserMutation) AddAlbumIDs(ids ...int) {
	if m.album == nil {
		m.album = make(map[int]struct{})
	}
	for i := range ids {
		m.album[ids[i]] = struct{}{}
	}
}

// ClearAlbum clears the "album" edge to the Album entity.
func (m *UserMutation) ClearAlbum() {
	m.clearedalbum = true
}

// AlbumCleared reports if the "album" edge to the Album entity was cleared.
func (m *UserMutation) AlbumCleared() bool {
	return m.clearedalbum
}

// RemoveAlbumIDs removes the "album" edge to the Album entity by IDs.
func (m *UserMutation) RemoveAlbumIDs(ids ...int) {
	if m.removedalbum == nil {
		m.removedalbum = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.album, ids[i])
		m.removedalbum[ids[i]] = struct{}{}
	}
}

// RemovedAlbum returns the removed IDs of the "album" edge to the Album entity.
func (m *UserMutation) RemovedAlbumIDs() (ids []int) {
	for id := range m.removedalbum {
		ids = append(ids, id)
	}
	return
}

// AlbumIDs returns the "album" edge IDs in the mutation.
func (m *UserMutation) AlbumIDs() (ids []int) {
	for id := range m.album {
		ids = append(ids, id)
	}
	return
}

// ResetAlbum resets all changes to the "album" edge.
func (m *UserMutation) ResetAlbum() {
	m.album = nil
	m.clearedalbum = false
	m.removedalbum = nil
}

// AddPictureIDs adds the "picture" edge to the Picture entity by ids.
func (m *UserMutation) AddPictureIDs(ids ...int) {
	if m.picture == nil {
		m.picture = make(map[int]struct{})
	}
	for i := range ids {
		m.picture[ids[i]] = struct{}{}
	}
}

// ClearPicture clears the "picture" edge to the Picture entity.
func (m *UserMutation) ClearPicture() {
	m.clearedpicture = true
}

// PictureCleared reports if the "picture" edge to the Picture entity was cleared.
func (m *UserMutation) PictureCleared() bool {
	return m.clearedpicture
}

// RemovePictureIDs removes the "picture" edge to the Picture entity by IDs.
func (m *UserMutation) RemovePictureIDs(ids ...int) {
	if m.removedpicture == nil {
		m.removedpicture = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.picture, ids[i])
		m.removedpicture[ids[i]] = struct{}{}
	}
}

// RemovedPicture returns the removed IDs of the "picture" edge to the Picture entity.
func (m *UserMutation) RemovedPictureIDs() (ids []int) {
	for id := range m.removedpicture {
		ids = append(ids, id)
	}
	return
}

// PictureIDs returns the "picture" edge IDs in the mutation.
func (m *UserMutation) PictureIDs() (ids []int) {
	for id := range m.picture {
		ids = append(ids, id)
	}
	return
}

// ResetPicture resets all changes to the "picture" edge.
func (m *UserMutation) ResetPicture() {
	m.picture = nil
	m.clearedpicture = false
	m.removedpicture = nil
}

// Where appends a list predicates to the UserMutation builder.
func (m *UserMutation) Where(ps ...predicate.User) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.nickname != nil {
		fields = append(fields, user.FieldNickname)
	}
	if m.motto != nil {
		fields = append(fields, user.FieldMotto)
	}
	if m.height != nil {
		fields = append(fields, user.FieldHeight)
	}
	if m.weight != nil {
		fields = append(fields, user.FieldWeight)
	}
	if m.kind != nil {
		fields = append(fields, user.FieldKind)
	}
	if m.created_at != nil {
		fields = append(fields, user.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldNickname:
		return m.Nickname()
	case user.FieldMotto:
		return m.Motto()
	case user.FieldHeight:
		return m.Height()
	case user.FieldWeight:
		return m.Weight()
	case user.FieldKind:
		return m.Kind()
	case user.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user.FieldNickname:
		return m.OldNickname(ctx)
	case user.FieldMotto:
		return m.OldMotto(ctx)
	case user.FieldHeight:
		return m.OldHeight(ctx)
	case user.FieldWeight:
		return m.OldWeight(ctx)
	case user.FieldKind:
		return m.OldKind(ctx)
	case user.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldNickname:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNickname(v)
		return nil
	case user.FieldMotto:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMotto(v)
		return nil
	case user.FieldHeight:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHeight(v)
		return nil
	case user.FieldWeight:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWeight(v)
		return nil
	case user.FieldKind:
		v, ok := value.(user.Kind)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKind(v)
		return nil
	case user.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserMutation) AddedFields() []string {
	var fields []string
	if m.addheight != nil {
		fields = append(fields, user.FieldHeight)
	}
	if m.addweight != nil {
		fields = append(fields, user.FieldWeight)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case user.FieldHeight:
		return m.AddedHeight()
	case user.FieldWeight:
		return m.AddedWeight()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	case user.FieldHeight:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddHeight(v)
		return nil
	case user.FieldWeight:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddWeight(v)
		return nil
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(user.FieldHeight) {
		fields = append(fields, user.FieldHeight)
	}
	if m.FieldCleared(user.FieldWeight) {
		fields = append(fields, user.FieldWeight)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	switch name {
	case user.FieldHeight:
		m.ClearHeight()
		return nil
	case user.FieldWeight:
		m.ClearWeight()
		return nil
	}
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldNickname:
		m.ResetNickname()
		return nil
	case user.FieldMotto:
		m.ResetMotto()
		return nil
	case user.FieldHeight:
		m.ResetHeight()
		return nil
	case user.FieldWeight:
		m.ResetWeight()
		return nil
	case user.FieldKind:
		m.ResetKind()
		return nil
	case user.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.devices != nil {
		edges = append(edges, user.EdgeDevices)
	}
	if m.notification_config != nil {
		edges = append(edges, user.EdgeNotificationConfig)
	}
	if m.album != nil {
		edges = append(edges, user.EdgeAlbum)
	}
	if m.picture != nil {
		edges = append(edges, user.EdgePicture)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeDevices:
		ids := make([]ent.Value, 0, len(m.devices))
		for id := range m.devices {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeNotificationConfig:
		ids := make([]ent.Value, 0, len(m.notification_config))
		for id := range m.notification_config {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeAlbum:
		ids := make([]ent.Value, 0, len(m.album))
		for id := range m.album {
			ids = append(ids, id)
		}
		return ids
	case user.EdgePicture:
		ids := make([]ent.Value, 0, len(m.picture))
		for id := range m.picture {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removeddevices != nil {
		edges = append(edges, user.EdgeDevices)
	}
	if m.removednotification_config != nil {
		edges = append(edges, user.EdgeNotificationConfig)
	}
	if m.removedalbum != nil {
		edges = append(edges, user.EdgeAlbum)
	}
	if m.removedpicture != nil {
		edges = append(edges, user.EdgePicture)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeDevices:
		ids := make([]ent.Value, 0, len(m.removeddevices))
		for id := range m.removeddevices {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeNotificationConfig:
		ids := make([]ent.Value, 0, len(m.removednotification_config))
		for id := range m.removednotification_config {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeAlbum:
		ids := make([]ent.Value, 0, len(m.removedalbum))
		for id := range m.removedalbum {
			ids = append(ids, id)
		}
		return ids
	case user.EdgePicture:
		ids := make([]ent.Value, 0, len(m.removedpicture))
		for id := range m.removedpicture {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.cleareddevices {
		edges = append(edges, user.EdgeDevices)
	}
	if m.clearednotification_config {
		edges = append(edges, user.EdgeNotificationConfig)
	}
	if m.clearedalbum {
		edges = append(edges, user.EdgeAlbum)
	}
	if m.clearedpicture {
		edges = append(edges, user.EdgePicture)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	switch name {
	case user.EdgeDevices:
		return m.cleareddevices
	case user.EdgeNotificationConfig:
		return m.clearednotification_config
	case user.EdgeAlbum:
		return m.clearedalbum
	case user.EdgePicture:
		return m.clearedpicture
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	switch name {
	case user.EdgeDevices:
		m.ResetDevices()
		return nil
	case user.EdgeNotificationConfig:
		m.ResetNotificationConfig()
		return nil
	case user.EdgeAlbum:
		m.ResetAlbum()
		return nil
	case user.EdgePicture:
		m.ResetPicture()
		return nil
	}
	return fmt.Errorf("unknown User edge %s", name)
}
